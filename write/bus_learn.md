
#关于通信总线类（UART、I2C、SD等）的工作建议

作为BSP工程师（驱动工程师），其工作职责说到根本上就是通过软件去控制硬件的行为，看起来就是这么一个目的，可是能够真正通过软件准确无误的去控制硬件行为不太容易做到，特别是在内核中去这么做。

由于以前很少有人在这方面做总结，所以过去在类似的工作中走了很多弯路，在结合前段时间的工作中了解到的情况（部分调试者都控制不住硬件的行为就敢随便改动代码并提交，这是一种不负责的表现，部分测试FPGA的新同事不了解硬件的工作原理就去测试），现在不想让大家特别是新来的同事再走同样的弯路，并且为了提高各位的工作效率以及避免未来大家维护隐藏在驱动代码中的一些bug，这里总结了关于在总线类（I2C、SPI、UART、SD、USB、SPDIF、I2S、PCM等等）的工作方面的一些建议：

弄清楚硬件的工作原理，如果仅仅看硬件的手册而思考的不够多，很多手册中的东西根本就不明白，根据不明白或者似懂非懂的东西写出来的驱动代码太可怕了，因为作为写的这个人压根儿就控制不住硬件的行为，以后无论你调试这段代码还是别人调试都挺麻烦的，特别是把这样的代码放到了内核驱动中。然而思考，又去思考哪些内容呢？或者说该怎么去思考呢？下面以简单的I2C，UART和SPI通信方式来介绍一下，至于复杂的SD/SDIO和USB也不会脱离下面讲的范围，可以在工作中自己去套用。

首先，以一条为主线“处理器（中的控制器或者PHY）和所连接的设备是怎么通信的？硬件提供了哪些接口供软件控制硬件的通信？软件在什么情况下使用哪些接口去控制硬件的行为”。硬件本身是不具备思想的，你要想和它通信必须要按照它的要求（协议）去做才可，就像你想和一个只能讲法语的人去交流，你只能通过法语，你不能用汉语或者英语，硬件和硬件本身也是这样。
上面提到的那些总线类的通信都是通过连接起来进行的，在电子设备中，这种连接起来的硬件通信方式一般通过两种方式进行：一种是数字信号，也就是高低电平，或者称为逻辑1和逻辑0（这里务必弄明白，逻辑1和逻辑0和高低电平并不是可以直接划等号的，比如在UART的RS232接口上就不能简单的划等号，UART通信时空闲情况下是逻辑1，是高电平，而通过RS232接口传输后，UART的逻辑1还是逻辑1，但是电平就转变为-3到-15V之间了，明白了吗？所以以后在遇到类似问题务必要弄明白这点）这种方式用到的最多，比如UART，I2C，SPI，SD/SDIO，USB的全速和低速模式等等；另一种是模拟信号，用这种通信的总线相对少一些，常见的有USB的高速模式（有的人会把USB高速模式概括为模拟信号的数字形式）。

## 1，总线的拓扑结构是怎样的？或者说控制器和设备是怎么相连的？电路原理图中硬件的连接方式是怎样的？

>请思考这样的问题：有几个线连接？各个线的功能时什么？如果是数字信号传输，线上的高低电平怎么得到？是什么连接方式？分主从设备吗？如果分主从设备，那么主设备是如何选择特定的从设备进行通信的？

###   A，比如I2C总线，有几根线？线上的高电平怎么得到？低电平怎么得到？（有两个线，一根是数据线，一根是时钟线，它们是需要上拉电阻获得高电平的）。I2C是主从连接方式吗？
	（一主多从的连接方式，有一个主设备多个从设备，主设备在通信过程中处于主导地位，表现形式就是主设备的是通信的时钟源，当主设备有数据需要发送时，那么主设备的时钟就是启动，并发送数据，从设备根据时钟线的变化来采集数据线上的数据）

### B、UART有几根线？连接方式怎样？高低电平怎么得到？
	（UART一般是一对一的连接（除非应用场景特殊），没有主从之分，UART最简单的传输有两根线，一个是TX，用于传输数据，一个是RX，用于接收数据，两个设备间的连接是交叉连接的，也就是设备A的RX和设备B的TX相连，设备A的TX和设备B的RX相连，复杂一点，还会有RTS和CTS，它们的作用是用于数据传输过程中同步使用，CTS是作为输入，RTS是输出，它们也是交叉连接的，当接收端的FIFO满了，暂时不能在接收数据，那么就把它的RTS拉高，这样发送端的CTS变低后，那么发送端就不再发送数据，这样就能保证传输过程中数据不丢失。）
	C、SPI有几根线？线上的高低电平怎么得到？是主从连接方式吗？
	（SPI最少使用四根线，数据接收线，数据发送线，时钟线，片选线，如果片选有多个，一个SPI控制器可以连接多个SPI设备，但是他们是通过片选来选择。	SPI也是一种主从的通信方式，一个为主设备，用于传输的发起，其他为从设备。SPI设备是通过片选的电平来选择的。）
	D、SD，SD协议有几根线？线上的高低电平怎么得到？是主从连接方式吗？
	（SD也是一种主从通信方式，一般有四根数据线，一条时钟线，一个cmd线，一个card探测线，有的还有写保护线。除了时钟线上没有上拉以外，其他都有一个上拉电阻，上拉电阻的阻值会影响到通信波形的上升沿的上升时间，电阻越大，上升时间越长）

2，如果是数字信号通信的话，通信协议是什么？
	2.1 空闲状态下，总线上各pin的电平状态是什么？
	这是最基本的，根据这个状态可以推断出设计中很多信息（作为BSP工程师，理解总线的通信必须要站在设计者的角度去考虑问题，只有这样，你才能理解的更深入），以I2C为例，I2C由于时钟线和数据线都有一个上拉电阻，所以空闲状态下线上的电平状态是高电平（为什么这么设计？）（首先I2C的时钟和数据线都不能输出高电平（为什么这么设计？SPI和UART为什么不用接上拉？考虑一下吧），他们在电子设计上是开漏设计的，如果要输出低电平，直接与地相连即可以，如果要输出高电平，只能通过外部接一个上拉电阻得到。所以I2C控制器控制时钟和数据线上的电平状态是通过拉低总线或者释放总线得到的。从功耗角度来说，空闲状态下维持高电平，也就是主端和从端都释放总线是最合理的设计方式，如果是低电平，设备的功耗就会增大，毕竟空闲的时间要比使用的时间多的多。），既然空闲状态下是高电平，那么起始信号就来了，主端有数据需要传输或者接收时，首先拉低数据线，这个过程时钟线是维持不变的，所以这就是一个起始信号，（为什么这么设计？为什么不是时钟线在数据线为高电平时由高变低就是起始信号呢？这么设计的好处有很多：（1）这样就可以做到在时钟线为低电平时数据线变化是传输，在时钟线是高电平时数据线变化是停止或者开始信号，否则是不能做到这样的目的的；（2）这样可以避免主端的数据线没有正确连接（比如数据线接触不良、虚焊）而导致从设备（能够对0xff进行响应）能够进行正确的响应的情况。）。接下来就可以进行数据传输了，数据的传输过程是怎样的？起始信号后，数据线为低电平，时钟线为高电平，首先时钟线由低变高，开始数据的传输，数据线在时钟线为低电平时进行电平状态的变化，在时钟线为高电平时进行数据线的采样（设备端是怎么根据时钟线上的电平变化采集信号的呢？这个是I2C的规定，I2C规定是以电平状态进行数据采样，而不是像SD那样用时钟线的边沿进行采样。）。这样传输直到8个时钟完毕，到第九个时钟的低电平时，发送端释放数据总线，设备端会拉低数据总线，这也就是所谓的ACK（为什么有ACK，这是为了表示通信的正确性，有ACK就表明前面的数据传输过程是OK的，不存在问题，这点要比SPI要好多了）。接收端应答完了，在第9个时钟的下降沿，接收端也会释放总线，这样在第10个时钟的低电平时，数据线就变成了高电平，这时候主设备端就会拉住数据总线，等到第10个时钟的高电平到来后，主设备由释放总线，这就是一个停止信号。
	从空闲状态就可以一路推导下去。
	请以此推导SPI、SD、UART的协议。
	请思考为什么I2C的速度要比SPI和SD等慢？这是由于它是以电平采样导致的，其他的两种都是以边沿采样，由于电平采样，所以电平需要维持一定的时间，特别是有上拉电阻的电路中。
	I2C，空闲状态下，全部为高电平；UART空闲状态下TX和RX为逻辑1，这里是高电平；SPI空闲状态下数据线和时钟线为高电平；SD空闲状态下，时钟线，命令线和数据线全为高电平
	2.2 是怎么进行数据同步的，有没有时钟线？如果有时钟线，那么什么时候接收端进行采样，什么时候发送端进行数据的变化？
	关于同步是软件工程师必须要考虑的，弄清楚了硬件上的同步，那么软件就可以控制住硬件的行为。
	这里以UART和SPI为例，UART由于没有时钟线，所以数据的同步是通信两端进行协商的，这也就是为什么在使用UART时，需要设置，停止位的个数，奇偶检验位，数据位，波特率等信息，就是靠这些信息，通信两端进行同步的，详细来说，通信两端都在不断检测RX上的逻辑变化，当由逻辑1变为逻辑0时，就认为传输开始，需要接收数据，并且以协商好的波特率进行数据的采样，根据协商好的数据位、奇偶校验位、停止位来接收一个数据包。
	SPI有一个时钟线，在传输过程中，根据配置的情况，接收端由时钟线上的时钟对数据线上的数据进行采样。
	23 开始信号是什么？停止信号是什么？
	UART开始信号是RX上的电平由高变低，停止信号是有低变高。SPI只要时钟线由空闲电平状态变成反状态，就认为传输开始，时钟停止就认为传输结束。SD只要CMD线上或者DATA线上的电平由空闲状态的高电平变为低电平就认为是传输开始。
	2.4 有没有数据传输校验机制？如果有，那么校验的过程是怎样的？校验的原理是什么？
	I2C通过ACK可以知道传输的正确性，SD和USB协议有CRC校验，UART有奇偶校验机制，SPI啥都没有，只能通过软件去检测数据的正确性。

3，软件如何控制住硬件的行为？
	3.1 硬件提供了哪些机制（方式）让软件控制硬件的传输开始和停止？控制器中哪些寄存器用于控制传输的开始？怎么控制传输的结束，或者中止传输？软件在配置这些寄存器前还有没有其他依赖条件，比如时钟等？

	3.2 硬件提供了哪些机制（方式）让软件知道硬件的传输的状态？控制器有没有提供一些机制来表示传输的状态？软件怎么用这些状态？


3.3 软件怎么知道传输的正确性与否？如果传输出问题？软件该怎么处理？


4，硬件的职责是什么？软件的职责是什么？
	硬件的职责就是听软件的话，发送或者接受数据，软件的职责就是让硬件发送或者接受数据。

5，应用的场景是怎样的？在应用场景中数据的流向是怎样的？
这点特别重要，有了应用场景，你写的代码和硬件才能活起来，才能让你从宏观上把握住系统。这样也能让你对前面的问题理解的更深刻，你的问题也会更多。所以先搞清楚应用的场景是非常关键的。

本文还有其他没有涉及到的细节，以后再不断补充。
