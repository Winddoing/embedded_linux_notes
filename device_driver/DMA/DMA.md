
# DMA

DMA传送不经过CPU的控制，假如硬盘的数据不能经过DMA控制器读到内存，那么每完成一次将硬盘的数据读出来，再存放到内存的操作，都要通过CPU运行几条读写指令来完成，这时CPU就做不了别的事了，如果有DMA控制器，则这个过程不需要CPU的参与，只需要占用总线就可以了。CPU还可以去完成别的运算。

> 对比:
> Burst操作还是要通过CPU的参与的，与单独的一次读写操作相比，burst只需要提供一个其实地址就行了，以后的地址依次加1，而非burst操作每次都要给出地址，以及需要中间的一些应答、等待状态等等。如果是对地址连续的读取，burst效率高得多，但如果地址是跳跃的，则无法采用burst操作

## 基本功能。

1. 普通的内存、外设间互传数据，一次性的。
2. 支持链表的，美其名曰`scatter`，内核有struct scatter可以参考, 应用mmc子系统中部分控制器的驱动。

## 相关概念

### burst

dma实际上是一次一次的申请总线，把要传的数据总量分成一个一个小的数据块。比如要传64个字节，那么dma内部可能分为2次，一次传64/2=32个字节，这个2(a)次呢，就叫做burst。这个burst是可以设置的。这32个字节又可以分为32位 *8或者16位*16来传输。

### transfer size：

就是数据宽度，比如8位、32位，一般跟外设的FIFO相同。

在最简单的DMA传输中，只需为DMA controller提供一个参数----`transfer size`，它就可以欢快的工作了：

> 在每一个时钟周期，DMA controller将1byte的数据从一个buffer搬到另一个buffer，直到搬完“transfer size”个bytes即可停止。

### transfer width
不过这在现实世界中往往不能满足需求，因为有些设备可能需要在一个时钟周期中，传输指定bit的数据，例如：

>memory之间传输数据的时候，希望能以总线的最大宽度为单位（32-bit、64-bit等），以提升数据传输的效率； 而在音频设备中，需要每次写入精确的16-bit或者24-bit的数据； 
>等等。

因此，为了满足这些多样的需求，我们需要为DMA controller提供一个额外的参数----`transfer width`。
 
### burst size：

就是一次传几个transfer size.

另外，当传输的源或者目的地是memory的时候，为了提高效率，DMA controller不愿意每一次传输都访问memory，而是在内部开一个buffer，将数据缓存在自己buffer中：

>memory是源的时候，一次从memory读出一批数据，保存在自己的buffer中，然后再一点点（以时钟为节拍），传输到目的地； memory是目的地的时候，先将源的数据传输到自己的buffer中，当累计一定量的数据之后，再一次性的写入memory。

这种场景下，DMA控制器内部可缓存的数据量的大小，称作`burst size`----另一个参数。


