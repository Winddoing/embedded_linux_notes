# 常见问题


## Unhandled kernel unaligned access

> 环境: mips linux3.10

```
[ 4402.567222] Unhandled kernel unaligned access[#1]:
[ 4402.573157] CPU: 0 PID: 0 Comm: swapper/0 Tainted: G        W    3.10.14-00104-g9244ae7-dirty #22
[ 4402.583302] task: 806065d0 ti: 805e8000 task.ti: 805e8000
[ 4402.589501] $ 0   : 00000000 14001800 06775410 0677541c
[ 4402.596069] $ 4   : 8c2c3130 8c28f710 800ab5f8 00000019
[ 4402.602609] $ 8   : 00000001 b2300000 ffffffe0 00000001
[ 4402.609056] $12   : 00000020 ffffffff 00000000 00420000
[ 4402.615539] $16   : 8c2c3130 35313a33 804cab00 805b8ce8
[ 4402.622002] $20   : 811f0000 8c28f710 8057799c 805779c4
[ 4402.628447] $24   : 00000000 8001abcc                  
[ 4402.635172] $28   : 805e8000 805e9c58 80630000 803afe60
[ 4402.641666] Hi    : 00000000
[ 4402.645060] Lo    : 00000048
[ 4402.648823] epc   : 803ae9e4 jz_audio_dma_isr+0x4c/0x1e0
[ 4402.654912]     Tainted: G        W   
[ 4402.659357] ra    : 803afe60 audio_irq_issue+0x8c/0xc8
[ 4402.665157] Status: 14001802   KERNEL EXL 
[ 4402.669823] Cause : 40808010
[ 4402.673938] BadVA : 35313a3b
[ 4402.678959] PrId  : 0013202f (Ingenix Xbusrt@II)
[ 4402.685827] Modules linked in:
[ 4402.692008] Process swapper/0 (pid: 0, threadinfo=805e8000, task=806065d0, tls=00000000)
[ 4402.702999] Stack : 80cc0000 800909d0 80cc22dc 00000000 80cc22ec 00000000 00000000 00000000
    00000040 00000006 804cab00 803afe60 805ead50 00000000 805ead60 00000000
    00000002 8c2ce700 00000008 805ead00 00000000 80608060 00000000 800ab3a4
    00000001 80cc22dc 80608060 00000000 ffffffff 805ead50 805ead50 8c2ce700
    805ead00 805ead50 8c2ce700 00000002 80608060 00000000 ffffffff 8ffc9384
    ...
[ 4402.782657] Call Trace:
[ 4402.787611] [<803ae9e4>] jz_audio_dma_isr+0x4c/0x1e0
[ 4402.795650] [<803afe60>] audio_irq_issue+0x8c/0xc8
[ 4402.803661] [<800ab3a4>] handle_irq_event_percpu+0xd0/0x2dc
[ 4402.812485] [<800ab604>] handle_irq_event+0x54/0x90
[ 4402.820609] [<800aea20>] handle_level_irq+0x134/0x154
[ 4402.828798] [<800aabb4>] generic_handle_irq+0x28/0x38
[ 4402.837151] [<8001add4>] do_IRQ+0x18/0x24
[ 4402.844019] [<80011328>] xburst2_irq_handle+0xc8/0xd8
[ 4402.852369] [<800aef40>] handle_percpu_devid_irq+0x120/0x1e8
[ 4402.861289] [<800aabb4>] generic_handle_irq+0x28/0x38
[ 4402.869586] [<8001add4>] do_IRQ+0x18/0x24
[ 4402.876557] [<80018980>] ret_from_irq+0x0/0x4
[ 4402.883948] [<8007f870>] cpu_startup_entry+0x64/0x294
[ 4402.892167] [<806399e4>] start_kernel+0x404/0x424
```


### alignment fault的代码编写方式

#### 指针转换：

将低位宽类型的指针转换为高位宽类型的指针，如：将char * 转为int *，或将void *转为结构体指针。这类操作是导致alignment fault的最主要的来源，在分析定位问题时，需要特别关注。对于出现异常却又必须这样使用的场景，对这类转换后的指针进行访问时，如果不能确认其对应的地址是对齐的，则应该使用memcpy访问(memcpy方式不存在对齐问题)。另外，建议转换后立即使用，不要将其传递到其他函数和模块，防止扩展，带来潜在的问题。

#### 使用packed属性或者编译选项

这样的操作会关闭编译器的自动填充功能，从而使结构体中各个字段紧凑排列，如果排列时未处理好对齐，则可能导致alignment fault。一些场景下(内核中也较常见)确实需要用户自行紧凑排列结构体，可节省空间(在内存资源稀缺的场景下，很有用)，此时需要特别关注对齐问题，建议通过填充的方法尽量对齐，如此可能会导致空间浪费，但是会提升访问性能，典型的“以空间换时间”的思路。如果对空间有强烈要求，而可以接受性能损失，也可以不考虑对齐，不做padding，但在访问这些结构体的数据时，需要全部使用memcpy的方式。
